using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using NUnit.Framework;
using Ploeh.AutoFixture.Kernel;

namespace Ploeh.AutoFixture.NUnit
{
    /// <summary>
    /// Provides auto-generated data specimens generated by AutoFixture as an extension to
    /// NUnit's <see cref="TestCaseAttribute"/>.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    [CLSCompliant(false)]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1813:AvoidUnsealedAttributes", Justification = "This attribute is the root of a potential attribute hierarchy.")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1019:DefineAccessorsForAttributeArguments", Justification = "These values are available from the base property 'Arguments'.")]
    public class AutoTestCaseAttribute : TestCaseAttribute
    {
        #region Constants and Static Fields

        private const string TypeDoesNotImplementIFixtureExceptionMessage = 
            "{0} is not compatible with IFixture. Please supply a Type which implements IFixture.";

        private const string TypeHasNoDefaultConstructorExceptionMessage =
            "{0} has no default constructor. Please supply a a Type that implements IFixture and has a default constructor. Alternatively you can supply an IFixture instance through one of the AutoDataAttribute constructor overloads. If used as an attribute, this can be done from a derived class.";

        private const string TypeDoesNotContainMethodExceptionMessage = 
            "Type '{0}' does not contain a method '{1}'. Please supply a method name that exists on the type.";

        #endregion

        #region Constructors and Destructors

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoTestCaseAttribute"/> class.
        /// </summary>
        /// <param name="testClassType">The type of the test class.</param>
        /// <param name="methodName">The name of the method.</param>
        /// <param name="manualParameters">An array of N objects that will be used as the first N parameters of the method.</param>
        /// <remarks>
        /// <para>
        /// This constructor overload initializes the <see cref="Fixture"/> to an instance of
        /// <see cref="Fixture"/>.
        /// </para>
        /// </remarks>
        /// <exception cref="ArgumentException">
        /// <paramref name="testClassType"/> does not contain a method <paramref name="methodName"/>.
        /// </exception>
        public AutoTestCaseAttribute(Type testClassType, string methodName, params object[] manualParameters)
            : this(testClassType, methodName, new Fixture(), manualParameters)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoTestCaseAttribute"/> class with an
        /// <see cref="IFixture"/> of the supplied type.
        /// </summary>
        /// <param name="testClassType">The type of the test class.</param>
        /// <param name="methodName">The name of the method.</param>
        /// <param name="fixtureType">The type of the composer.</param>
        /// <param name="manualParameters">An array of N objects that will be used as the first N parameters of the method.</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="fixtureType"/> does not implement <see cref="IFixture"/>
        /// or does not have a default constructor.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="testClassType"/> does not contain a method <paramref name="methodName"/>.
        /// </exception>
        public AutoTestCaseAttribute(Type testClassType, string methodName, Type fixtureType, params object[] manualParameters)
            : this(testClassType, methodName, CreateFixture(fixtureType), manualParameters)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AutoTestCaseAttribute"/> class with the
        /// supplied <see cref="IFixture"/>.
        /// </summary>
        /// <param name="testClassType">The type of the test class.</param>
        /// <param name="methodName">The name of the method.</param>
        /// <param name="fixture">The AutoFixture composer that will be used by this attribute.</param>
        /// <param name="manualParameters">An array of N objects that will be used as the first N parameters of the method.</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="testClassType"/> does not contain a method <paramref name="methodName"/>.
        /// </exception>
        public AutoTestCaseAttribute(Type testClassType, string methodName, IFixture fixture, object[] manualParameters)
            : base(CreateTestCaseArguments(testClassType, methodName, fixture, manualParameters))
        {
            _fixture = fixture;
            TestClassType = testClassType;
            MethodName = methodName;
        }

        #endregion

        #region Properties

        /// <summary>
        /// The fixture used to create the parameters for the test case.
        /// </summary>
        public IFixture Fixture
        {
            get { return _fixture; }
        }

        /// <summary>
        /// The type of the fixuture used to create the paramaters for the test case.
        /// </summary>
        public Type FixtureType
        {
            get { return _fixture.GetType(); }
        }

        /// <summary>
        /// The type of the test class that this test case is applied to.
        /// </summary>
        public Type TestClassType { get; private set; }

        /// <summary>
        /// The name of the method that this test case attribute is applied to.
        /// </summary>
        public string MethodName { get; private set; }
    
        #endregion

        #region Methods

        /// <summary>
        /// Creates a new fixture of the given type.
        /// </summary>
        /// <param name="fixtureType"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentException">fixtureType</exception>
        /// <exception cref="ArgumentNullException">fixtureType</exception>
        protected static IFixture CreateFixture(Type fixtureType)
        {
            if (fixtureType == null)
            {
                throw new ArgumentNullException("fixtureType");
            }

            if (!typeof (IFixture).IsAssignableFrom(fixtureType))
            {
                throw new ArgumentException(
                    string.Format(
                        CultureInfo.CurrentCulture, 
                        TypeDoesNotImplementIFixtureExceptionMessage, 
                        fixtureType),
                    "fixtureType");
            }

            var ctor = fixtureType.GetConstructor(Type.EmptyTypes);
            if (ctor == null)
            {
                throw new ArgumentException(
                    string.Format(
                        CultureInfo.CurrentCulture, 
                        TypeHasNoDefaultConstructorExceptionMessage, 
                        fixtureType),
                    "fixtureType");
            }

            return (IFixture) ctor.Invoke(null);
        }

        /// <exception cref="ArgumentNullException">fixture</exception>
        /// <exception cref="ArgumentException"></exception>
        private static object[] CreateTestCaseArguments(Type testClassType, string methodFullName, IFixture fixture, object[] manualParameters)
        {
            if (fixture == null)
                throw new ArgumentNullException("fixture");

            MethodInfo methodInfo = testClassType.GetMethod(methodFullName);
            if (methodInfo == null)
            {
                throw new ArgumentException(
                    string.Format(
                        CultureInfo.CurrentCulture, 
                        TypeDoesNotContainMethodExceptionMessage, 
                        testClassType.FullName, 
                        methodFullName));
            }

            return GetArguments(testClassType.FullName, methodInfo,fixture,manualParameters);
        }

        private static object[] GetArguments(string typeName, MethodInfo methodInfo, IFixture fixture, object[] manualParameters)
        {
            var specimens = new List<object>();
            var manualParameterQueue = new Queue<object>(manualParameters);
            foreach (var parameterInfo in methodInfo.GetParameters())
            {
                if (manualParameterQueue.Any())
                {
                    specimens.Add(manualParameterQueue.Dequeue());
                }
                else
                {
                    var specimen = ParameterStore.GetOrAdd(typeName, parameterInfo,
                    i =>
                    {
                        CustomizeFixture(i, fixture);
                        return Resolve(i, fixture);
                    });
                    specimens.Add(specimen);
                }
            }

            return specimens.ToArray();
        }

        private static void CustomizeFixture(ParameterInfo parameterInfo, IFixture fixture)
        {
            var customizeAttributes = parameterInfo.GetCustomAttributes(typeof(CustomizeAttribute), false)
                                                   .OfType<CustomizeAttribute>();

            foreach (var customizeAttribute in customizeAttributes)
            {
                var c = customizeAttribute.GetCustomization(parameterInfo);
                fixture.Customize(c);
            }
        }

        private static object Resolve(ParameterInfo parameterInfo, IFixture fixture)
        {
            var context = new SpecimenContext(fixture);
            return context.Resolve(parameterInfo);
        }

        #endregion

        #region Fields

        private readonly IFixture _fixture;

        #endregion
    }
}